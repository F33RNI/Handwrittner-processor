"""
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.
In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
For more information, please refer to <https://unlicense.org>
"""

import os

import PIL
import cv2
import numpy as np
import pdf2image

# Path to .pdf file from handwrittner.com
PATH_TO_HANDWRITTENER_PDF = "C:\\Users\\F3rni\\Documents\\Polytech\\магистратура\\защита интеллектуальной собственности\\handwrittner.com-POPxzexL.pdf"

# Specify the resolution in which to read pages from a PDF file
HANDWRITTENER_FILE_DPI = 600

# Paddings of odd and even pages in PDF generated by handwrittner.com (in mm)
HANDWRITTENER_PADDING_LEFT_ODD_MM = 5
HANDWRITTENER_PADDING_TOP_ODD_MM = 7
HANDWRITTENER_PADDING_RIGHT_ODD_MM = 25
HANDWRITTENER_PADDING_BOTTOM_ODD_MM = 45
HANDWRITTENER_PADDING_LEFT_EVEN_MM = 25
HANDWRITTENER_PADDING_TOP_EVEN_MM = 7
HANDWRITTENER_PADDING_RIGHT_EVEN_MM = 5
HANDWRITTENER_PADDING_BOTTOM_EVEN_MM = 45

# Color threshold for keeping letters outside the required area. Letters will be saved STARTING from this value
# Keep it as high as possible without getting background visible
COLOR_KEEP_THRESHOLD_BGR = (220, 0, 0)

# Path to result (output file) .pdf
PATH_TO_OUTPUT_PDF = "Практическая 1-2.pdf"

# Size of output pages in mm
# Letter: 215.9 X 279.4
# A4: 297 X 210
# A5: 210 X 148
OUTPUT_FILE_WIDTH_MM = 215.9
OUTPUT_FILE_HEIGHT_MM = 279.4

# Specify the resolution in which to save processed pages
OUTPUT_FILE_DPI = 600

# Target left and right paddings (in mm) will be added to the output file
# Experiment with these values to get right size of checkered grid
# The top and bottom paddings will be calculated automatically
OUTPUT_FILE_PADDING_LEFT_ODD_MM = 20
OUTPUT_FILE_PADDING_RIGHT_ODD_MM = 15
OUTPUT_FILE_PADDING_LEFT_EVEN_MM = 15
OUTPUT_FILE_PADDING_RIGHT_EVEN_MM = 20

# Press the green button in the gutter to run the script.
if __name__ == "__main__":
    # Create output directory if not exists
    # if not os.path.exists(OUTPUT_DIRECTORY):
    #    print("Creating " + OUTPUT_DIRECTORY + " directory")
    #    os.makedirs(OUTPUT_DIRECTORY)

    # Read PDF file
    print("Reading file: " + PATH_TO_HANDWRITTENER_PDF)
    pages = pdf2image.convert_from_path(PATH_TO_HANDWRITTENER_PDF,
                                        dpi=HANDWRITTENER_FILE_DPI,
                                        poppler_path=os.path.join("poppler-0.68.0", "bin"))

    # List of result images to write into output PDF
    result_images = []

    # List all pages
    for i in range(len(pages)):
        print("Processing page " + str(i + 1) + "...")

        # Convert to opencv image
        image = cv2.cvtColor(np.array(pages[i]), cv2.COLOR_RGB2BGR)
        image_width = image.shape[1]
        image_height = image.shape[0]
        image_width_mm = image_width / HANDWRITTENER_FILE_DPI * 25.4
        image_height_mm = image_height / HANDWRITTENER_FILE_DPI * 25.4

        # Calculate dimensions of output file in pixes
        output_file_width = int(OUTPUT_FILE_WIDTH_MM / 25.4 * OUTPUT_FILE_DPI)
        output_file_height = int(OUTPUT_FILE_HEIGHT_MM / 25.4 * OUTPUT_FILE_DPI)

        # Calculate is page odd or even
        page_even = (i + 1) % 2 == 0

        # Calculate paddings in pixels
        if page_even:
            handwrittener_padding_left = int(HANDWRITTENER_PADDING_LEFT_EVEN_MM / image_width_mm * image_width)
            handwrittener_padding_top = int(HANDWRITTENER_PADDING_TOP_EVEN_MM / image_height_mm * image_height)
            handwrittener_padding_right = int(HANDWRITTENER_PADDING_RIGHT_EVEN_MM / image_width_mm * image_width)
            handwrittener_padding_bottom = int(HANDWRITTENER_PADDING_BOTTOM_EVEN_MM / image_height_mm * image_height)
            output_padding_left = int(OUTPUT_FILE_PADDING_LEFT_EVEN_MM / OUTPUT_FILE_WIDTH_MM * output_file_width)
            output_padding_right = int(OUTPUT_FILE_PADDING_RIGHT_EVEN_MM / OUTPUT_FILE_WIDTH_MM * output_file_width)

        else:
            handwrittener_padding_left = int(HANDWRITTENER_PADDING_LEFT_ODD_MM / image_width_mm * image_width)
            handwrittener_padding_top = int(HANDWRITTENER_PADDING_TOP_ODD_MM / image_height_mm * image_height)
            handwrittener_padding_right = int(HANDWRITTENER_PADDING_RIGHT_ODD_MM / image_width_mm * image_width)
            handwrittener_padding_bottom = int(HANDWRITTENER_PADDING_BOTTOM_ODD_MM / image_height_mm * image_height)
            output_padding_left = int(OUTPUT_FILE_PADDING_LEFT_ODD_MM / OUTPUT_FILE_WIDTH_MM * output_file_width)
            output_padding_right = int(OUTPUT_FILE_PADDING_RIGHT_ODD_MM / OUTPUT_FILE_WIDTH_MM * output_file_width)

        # Calculate resize factor by dividing target zone width by source zone width
        resize_k = (output_file_width - output_padding_left - output_padding_right) \
                   / (image_width - handwrittener_padding_left - handwrittener_padding_right)

        # Calculate top and bottom paddings (in pixels) of zone of output image
        target_zone_height = (image_height - handwrittener_padding_top - handwrittener_padding_bottom) * resize_k
        output_padding_top_bottom = int((output_file_height - target_zone_height) / 2)

        # Calculate where we need to paste resized handwritten image into result image (relative to result image)
        paste_x = int(output_padding_left - (handwrittener_padding_left * resize_k))
        paste_y = int(output_padding_top_bottom - (handwrittener_padding_top * resize_k))

        # Create mask where black region is where we need to remove checkered background
        mask = np.zeros((image_height, image_width), dtype=np.uint8)
        mask[handwrittener_padding_top: image_height - handwrittener_padding_bottom,
        handwrittener_padding_left: image_width - handwrittener_padding_right] = 255

        # Create mask of all text by color
        text_mask = cv2.inRange(image, COLOR_KEEP_THRESHOLD_BGR, (255, 255, 255))

        # Invert text mask so, white pixels are where text is
        text_mask = cv2.bitwise_not(text_mask)

        # Combine both masks
        mask = cv2.bitwise_or(mask, text_mask)

        # Convert mask to 3 channels
        mask = cv2.cvtColor(mask, cv2.COLOR_GRAY2BGR)

        # Apply mask to image (make all pixels white where we need to remove checkered background)
        image[(mask == 0).all(-1)] = (255, 255, 255)

        # Generate output image
        result_image = np.ones((output_file_height, output_file_width, 3), dtype=np.uint8) * 255

        # Resize handwrittener image
        image_resized = cv2.resize(image, (int(image_width * resize_k), int(image_height * resize_k)))

        # Remove negative overflows of resized image, so we can paste it safely
        if paste_x < 0:
            image_resized = image_resized[:, -paste_x:]
        if paste_y < 0:
            image_resized = image_resized[-paste_y:, :]

        # Remove positive overflows of resized image, so we can paste it safely
        if image_resized.shape[1] + max(paste_x, 0) > output_file_width:
            image_resized = image_resized[:, : output_file_width - max(paste_x, 0)]

        if image_resized.shape[0] + max(paste_y, 0) > output_file_height:
            image_resized = image_resized[: output_file_height - max(paste_y, 0), :]

        # Paste image
        paste_from_x = max(paste_x, 0)
        paste_from_y = max(paste_y, 0)
        paste_to_x = image_resized.shape[1] + paste_from_x
        paste_to_y = image_resized.shape[0] + paste_from_y
        result_image[paste_from_y: paste_to_y, paste_from_x: paste_to_x] = image_resized

        # Uncomment for debug
        # cv2.imshow("Image", cv2.resize(result_image, (result_image.shape[1] // 5, result_image.shape[0] // 5)))
        # cv2.waitKey(0)

        # Convert to PIL image
        pil_image = PIL.Image.fromarray(cv2.cvtColor(result_image, cv2.COLOR_BGR2RGB))

        # Add image to list
        if pil_image is not None:
            result_images.append(pil_image)
            print("Page " + str(i + 1) + " successfully processed")

    # Save all PIL images as one PDF file
    print("Saving to " + PATH_TO_OUTPUT_PDF)
    result_images[0].save(
        PATH_TO_OUTPUT_PDF, "PDF", resolution=OUTPUT_FILE_DPI, save_all=True, append_images=result_images[1:]
    )

    # All pages processed and saved
    print("Done!")
